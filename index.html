<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>棋士データ</title>
  <link rel="stylesheet" href="style.css" />
  <style>
    #mobile-container { display: block; }
    #pc-container { display: none; }

    @media (min-width: 769px) {
      #mobile-container { display: none; }
      #pc-container { display: block; }
    }

    table { border-collapse: collapse; width: 100%; }
    th, td { border: 1px solid #ccc; padding: 4px; text-align: left; }
    th.sortable { cursor: pointer; }
    th.sortable::after { content: " ⇅"; font-size: .8em; color: #888; }
    th.sorted-asc::after { content: " ▲"; color: #000; }
    th.sorted-desc::after { content: " ▼"; color: #000; }
    td.rank, th.rank { text-align: center; width: 3em; }
    .controls { margin: .5em 0; }
  </style>
</head>
<body>
  <h1>棋士データ</h1>

  <!-- PC版 -->
  <div id="pc-container">
    <div class="controls">
      <input type="text" id="searchBox" placeholder="検索..." />
    </div>
    <table id="pc-table">
      <thead>
        <tr>
          <th class="sortable" data-key="name">棋士名</th>
          <th class="sortable" data-key="birth">生年月日</th>
          <th class="sortable" data-key="promo">四段昇段日</th>
          <th class="sortable" data-key="no">棋士番号</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

  <!-- モバイル版 (mobile2.htmlのUIを再現) -->
  <div id="mobile-container">
    <div class="controls">
      <label for="sort-select">並び替え基準:</label>
      <select id="sort-select">
        <option value="">-- 並び替え未選択 --</option>
        <option value="kishiNumber">棋士番号</option>
        <option value="birthdate">生年月日</option>
        <option value="currentAge">現年齢</option>
        <option value="ageAtPromotion">四段昇段時年齢</option>
      </select>
      <div>
        <label><input type="radio" name="sortOrder" value="asc" checked> 昇順</label>
        <label><input type="radio" name="sortOrder" value="desc"> 降順</label>
      </div>
      <button type="button" onclick="applyMobileSort()">並び替える</button>
    </div>
    <table id="mobile-table">
      <thead>
        <tr>
          <th class="rank">順位</th>
          <th>棋士名</th>
          <th id="col-label"></th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

  <script>
    let people = [];
    let currentPCSortKey = 'name';
    let currentPCSortOrder = 'asc';
    let currentSortOrder = 'asc'; // モバイル用

    function parseDate(str) {
      const d = new Date(str);
      return isNaN(d) ? null : d;
    }
    function toNumber(str) {
      const n = Number(str);
      return isNaN(n) ? Number.POSITIVE_INFINITY : n;
    }
    function diffYMD(start, end) {
      if (!start || !end) return null;
      let y = end.getFullYear() - start.getFullYear();
      let m = end.getMonth() - start.getMonth();
      let d = end.getDate() - start.getDate();
      if (d < 0) {
        const prevMonthLast = new Date(end.getFullYear(), end.getMonth(), 0);
        d += prevMonthLast.getDate();
        m -= 1;
      }
      if (m < 0) {
        m += 12;
        y -= 1;
      }
      return { y, m, d };
    }
    function formatYMD(parts) {
      if (!parts) return '';
      return `${parts.y}歳${parts.m}ヶ月${parts.d}日`;
    }

    async function loadData() {
      const res = await fetch('kishi.csv');
      if (!res.ok) throw new Error('CSV読み込み失敗: ' + res.status);
      const text = await res.text();
      const rowsRaw = text.trim().split(/\r?\n/).map(r => r.split(','));
      const header = rowsRaw.shift().map(h => h.trim());

      const nameIdx  = header.findIndex(h => h === '棋士名');
      const birthIdx = header.findIndex(h => h === '生年月日');
      const promoIdx = header.findIndex(h => h === '四段昇段日');
      const numIdx   = header.findIndex(h => h === '棋士番号');

      const today = new Date();
      people = rowsRaw.map(cols => {
        const name     = (cols[nameIdx]  || '').trim();
        const birthStr = (cols[birthIdx] || '').trim();
        const promStr  = (cols[promoIdx] || '').trim();
        const noStr    = (cols[numIdx]   || '').trim();

        const birth = parseDate(birthStr);
        const prom  = parseDate(promStr);

        return {
          name, birthStr, promStr, noStr,
          birth, prom,
          currentAgeParts: birth ? diffYMD(birth, today) : null,
          promoAgeParts: (birth && prom) ? diffYMD(birth, prom) : null,
          currentAgeDays: birth ? Math.floor((today - birth) / 86400000) : Number.POSITIVE_INFINITY,
          promoAgeDays: (birth && prom) ? Math.floor((prom - birth) / 86400000) : Number.POSITIVE_INFINITY,
          noNum: toNumber(noStr)
        };
      });
    }

    function renderMobileInitial() {
      const tbody = document.querySelector('#mobile-table tbody');
      tbody.innerHTML = people.map((p, i) => `
        <tr>
          <td class="rank">${i + 1}</td>
          <td>${p.name}</td>
          <td></td>
        </tr>
      `).join('');
    }

    function applyMobileSort() {
      // ラジオボタンでソート順を取得
      const orderRadio = document.querySelector('input[name="sortOrder"]:checked');
      currentSortOrder = orderRadio ? orderRadio.value : 'asc';

      const criterion = document.getElementById('sort-select').value;
      const labelMap = {
        kishiNumber: "棋士番号",
        birthdate: "生年月日",
        currentAge: "現年齢",
        ageAtPromotion: "四段昇段時年齢"
      };
      document.getElementById('col-label').textContent = labelMap[criterion] || "";

      const sorted = [...people].sort((a, b) => {
        let av, bv;
        switch (criterion) {
          case 'kishiNumber':     av = a.noNum;             bv = b.noNum;             break;
          case 'birthdate':       av = a.birth ? a.birth.getTime() : Infinity;
                                   bv = b.birth ? b.birth.getTime() : Infinity;       break;
          case 'currentAge':      av = a.currentAgeDays;    bv = b.currentAgeDays;    break;
          case 'ageAtPromotion':  av = a.promoAgeDays;      bv = b.promoAgeDays;      break;
          default:                av = 0;                   bv = 0;
        }
        return currentSortOrder === 'asc' ? av - bv : bv - av;
      });

      const tbody = document.querySelector('#mobile-table tbody');
      tbody.innerHTML = sorted.map((p, i) => `
        <tr>
          <td class="rank">${i + 1}</td>
          <td>${p.name}</td>
          <td>${
            criterion === 'kishiNumber'    ? (p.noStr ?? '') :
            criterion === 'birthdate'      ? (p.birthStr ?? '') :
            criterion === 'currentAge'     ? (p.currentAgeParts ? formatYMD(p.currentAgeParts) : '') :
            criterion === 'ageAtPromotion' ? (p.promoAgeParts ? formatYMD(p.promoAgeParts) : '') : ''
          }</td>
        </tr>
      `).join('');
    }

    function renderPC(list = people) {
      const tbody = document.querySelector('#pc-table tbody');
      tbody.innerHTML = list.map(p => `
        <tr>
          <td>${p.name}</td>
          <td>${p.birthStr}</td>
          <td>${p.promStr}</td>
          <td>${p.noStr ?? ''}</td>
        </tr>
      `).join('');
    }

    function attachPCSort() {
      const headers = document.querySelectorAll('#pc-table th.sortable');
      headers.forEach(h => {
        h.addEventListener('click', () => {
          currentPCSortKey = h.dataset.key;
          currentPCSortOrder = (h.classList.contains('sorted-asc')) ? 'desc' : 'asc';
          headers.forEach(x => x.classList.remove('sorted-asc', 'sorted-desc'));
          h.classList.add(currentPCSortOrder === 'asc' ? 'sorted-asc' : 'sorted-desc');
          sortPCData();
        });
      });
    }

    function sortPCData() {
      const sorted = [...people].sort((a, b) => {
        let av, bv;
        switch (currentPCSortKey) {
          case 'name':  av = a.name;  bv = b.name;  return currentPCSortOrder === 'asc'
            ? av.localeCompare(bv, 'ja') : bv.localeCompare(av, 'ja');
          case 'birth': av = a.birth ? a.birth.getTime() : 0;
                        bv = b.birth ? b.birth.getTime() : 0;
                        break;
          case 'promo': av = a.prom  ? a.prom.getTime()  : 0;
                        bv = b.prom  ? b.prom.getTime()  : 0;
                        break;
          case 'no':    av = a.noNum; bv = b.noNum; break;
        }
        return currentPCSortOrder === 'asc' ? av - bv : bv - av;
      });
      renderPC(sorted);
    }

    function applyPCSearch() {
      const q = (document.getElementById('searchBox')?.value || '').trim();
      const filtered = q
        ? people.filter(p =>
            p.name.includes(q) || p.birthStr.includes(q) || p.promStr.includes(q) || (p.noStr || '').includes(q)
          )
        : people;
      renderPC(filtered);
    }

    (async () => {
      await loadData();
      renderMobileInitial();
      renderPC();
      attachPCSort();
      const box = document.getElementById('searchBox');
      if (box) box.addEventListener('input', applyPCSearch);
    })();
  </script>
</body>
</html>